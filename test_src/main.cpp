
//#define MC_IMPORT
#include <pch1.h>
#include <vkgui/pnguo.h>
#include <vkgui/tinysdl3.h>
#include <vkgui/mapView.h>
#include <vkgui/print_time.h>
#include <mcut/stlrw.h>

#include <iostream>

#include <cairo/cairo.h>
#include <stdfloat>
#include "charts.h"
#include <vulkan/vulkan.h>
#include <vkvg/vkvgcx.h>

#include <vkgui/event.h>
#include <vkgui/page.h>
#include <vkgui/vkrenderer.h>
#include <stb_image_write.h>

#include <mimalloc.h>
#include <mimalloc-new-delete.h>

/*
	todo
	顶点数据、纹理/颜色数据、mvp矩阵
	渲染目标、着色器、管线、数据、指令
	- [x] PBR管线
	- [ ] 通用无光照管线
	- [ ] 地形管线（光照）
	- [ ] 粒子管线(光照)
	- [ ] 粒子管线(无光照)
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST

	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
cd build
cmake ..

# install in a different path. eg ~/test/usr/lib
cmake -DCMAKE_INSTALL_PREFIX=~/test ..

# static build
cmake -DBUILD_SHARED_LIBS=OFF ..
ninja -C build

*/

//struct v22
//{
//	glm::vec2 a, b;
//};
//glm::vec2 draw_r(cairo_t* cr, glm::vec4 t, float aj) {
//	t.w = 1;
//	glm::mat4 a = glm::rotate(glm::radians(aj), glm::vec3(1.0, 0.0, 0.0));//沿Z轴旋转90度
//	auto t2 = a * t;
//	auto tt = t;
//	tt *= 6;
//	draw_circle(cr, tt, 2);
//	fill_stroke(cr, 0xffffffff, 0, 1, false);
//	tt = t2;
//	tt *= 6;
//	draw_circle(cr, tt, 2);
//	fill_stroke(cr, 0xff00ff00, 0, 1, false);
//	return t2;
//}

#include <clipper2/clipper.h> 
using namespace Clipper2Lib;
#if 1
void tobox(const glm::vec2& v, glm::vec4& t);
void tobox0(const glm::vec2& v, glm::vec4& t)
{
	if (v.x < t.x)
	{
		t.x = v.x;
	}
	if (v.y < t.y)
	{
		t.y = v.y;
	}
	if (v.x > t.z)
	{
		t.z = v.x;
	}
	if (v.y > t.w)
	{
		t.w = v.y;
	}

}
static uint64_t toUInt(const njson& v, uint64_t de = 0)
{
	uint64_t ret = de;
	if (v.is_number())
	{
		ret = v.get<uint64_t>();
	}
	else if (!v.is_null())
	{
		ret = std::atoll(md::trim(v.dump(), "\"").c_str());
	}
	return ret;
}

njson& push_btn(const void* str, int cidx, int eid, njson& btn)
{
	njson it;
	it["s"] = (char*)(str ? str : "");
	it["cidx"] = cidx;
	it["eid"] = eid;
	btn.push_back(it);
	return *btn.rbegin();
}
/*
*
*  0中心
*   1     2
	-------
	|     |
	-------
	4     3
*/
glm::vec2 getbox2t_(std::vector<glm::vec2>& vt, int t)
{
	glm::vec4 box = { INT_MAX,INT_MAX,INT_MIN,INT_MIN };
	for (auto& it : vt)
	{
		tobox(it, box);
	}
	glm::vec2 cp = { box.z - box.x,box.w - box.y };
	switch (t)
	{
	case 0:
		cp *= 0.5;
		break;
	case 1:
		cp = {};
		break;
	case 2:
		cp.y = 0;
		break;
	case 3:
		break;
	case 4:
		cp.x = 0;
		break;
	default:
		break;
	}
	cp.x += box.x;
	cp.y += box.y;
	return cp;
}
glm::vec2 getbox2t_(const glm::vec2* vt, int count, int t)
{
	glm::vec4 box = { INT_MAX,INT_MAX,INT_MIN,INT_MIN };
	for (size_t i = 0; i < count; i++)
	{
		auto it = vt[i];
		tobox(it, box);
	}
	glm::vec2 cp = { box.z - box.x,box.w - box.y };
	switch (t)
	{
	case 0:
		cp *= 0.5;
		break;
	case 1:
		cp = {};
		break;
	case 2:
		cp.y = 0;
		break;
	case 3:
		break;
	case 4:
		cp.x = 0;
		break;
	default:
		break;
	}
	cp.x += box.x;
	cp.y += box.y;
	return cp;
}

glm::vec2 getbox2t_(glm::vec4 box, int t)
{
	glm::vec2 cp = { box.z - box.x,box.w - box.y };
	switch (t)
	{
	case 0:
		cp *= 0.5;
		break;
	case 1:
		cp = {};
		break;
	case 2:
		cp.y = 0;
		break;
	case 3:
		break;
	case 4:
		cp.x = 0;
		break;
	default:
		break;
	}
	cp.x += box.x;
	cp.y += box.y;
	return cp;
}
// 缩放基于获取图形包围盒，返回坐标t=0中心，1左上角，2右上角，3右下角，4左下角，
void scale_pts(glm::vec2* pts, int count, const glm::vec2& sc, int ddot, bool inv)
{
	auto cp = getbox2t_(pts, count, ddot);//获取包围盒
	glm::vec2 cp0 = {};
	glm::vec2 scale = sc;
	// 缩放
	assert(scale.x > 0 && scale.y > 0);
	if (scale.x > 0 && scale.y > 0)
	{
		auto m = glm::translate(glm::mat3(1.0f), glm::vec2(cp)) * glm::scale(glm::mat3(1.0f), scale)
			* glm::translate(glm::mat3(1.0f), glm::vec2(-cp));
		if (inv)
		{
			m = glm::inverse(m);// 撤销执行反向操作 
		}
		auto v = pts;
		for (size_t i = 0; i < count; i++)
		{
			glm::vec3 v3 = { v[i] ,1.0 };
			v[i] = glm::vec2(m * v3);
		}
	}
}
void draw_pts(cairo_t* cr, std::vector<glm::vec2>& ptv, uint32_t c) {

	cairo_move_to(cr, (int)ptv[0].x, (int)ptv[0].y);
	for (size_t i = 1; i < ptv.size(); i++)
	{
		auto v2 = ptv[i];
		cairo_line_to(cr, (int)v2.x, (int)v2.y);
	}
	cairo_close_path(cr);
	fill_stroke(cr, 0, c, 1, false);
}
#endif
struct vkdinfo {
	VkDevice				vkDev;					/**< Vulkan Logical Device */
	VkPhysicalDeviceMemoryProperties phyMemProps;	/**< Vulkan Physical device memory properties */
	VkPhysicalDevice		phy;					/**< Vulkan Physical device */
	VkInstance				instance;				/**< Vulkan instance */
};

void loadtestdata()
{
	auto ed = hz::read_json("ed.json");
	for (auto& [k, v] : ed.items()) {
		printf("%s\n", k.c_str());
	}
#if 1
	//m1.load_stl("E:\\d3\\cube.stl");
	//m1.load_obj("E:\\d3\\g.obj");
	//m2.load_stl("E:\\d3\\cone.stl");
	//m2.load_stl("E:\\d3\\cube1.stl");
	//m1.load_obj("E:\\d3\\cone.obj");
	//m1.load_obj("E:\\d3\\cube.obj");
	//m2.load_obj("E:\\d3\\cube1.obj");

#endif
	// 一格一物：		固体块、墙、气体、液体。种类不到200种
	// 可在气液体重叠：	固体、物件、建筑
	//return rdx12((HINSTANCE)GetModuleHandle(0), (char*)"", SW_SHOW, "abc");
	//return rvk((HINSTANCE)GetModuleHandle(0), (char*)"", SW_SHOW, "abc");
}

#include <xatlas/xatlas_c.h>
#include "mcut/mcut_cx.h"
//#include <variant>

struct GizmoGeomInfo {
	int nverts;
	int ntris;
	const glm::vec3* verts;
	const glm::vec3* normals;
	const int* indices;
};

namespace arrow_n {
	static glm::vec3 verts[] = {
		{-0.000000, 0.012320, 0.000000},  {-0.000000, 0.012320, 0.974306},
		{0.008711, 0.008711, 0.000000},   {0.008711, 0.008711, 0.974306},
		{0.012320, -0.000000, 0.000000},  {0.012320, -0.000000, 0.974306},
		{0.008711, -0.008711, 0.000000},  {0.008711, -0.008711, 0.974306},
		{-0.000000, -0.012320, 0.000000}, {-0.000000, -0.012320, 0.974306},
		{-0.008711, -0.008711, 0.000000}, {-0.008711, -0.008711, 0.974306},
		{-0.012320, 0.000000, 0.000000},  {-0.012320, 0.000000, 0.974306},
		{-0.008711, 0.008711, 0.000000},  {-0.008711, 0.008711, 0.974306},
		{0.000000, 0.072555, 0.974306},   {0.051304, 0.051304, 0.974306},
		{0.072555, -0.000000, 0.974306},  {0.051304, -0.051304, 0.974306},
		{-0.000000, -0.072555, 0.974306}, {-0.051304, -0.051304, 0.974306},
		{-0.072555, 0.000000, 0.974306},  {-0.051304, 0.051304, 0.974306},
		{0.000000, -0.000000, 1.268098},
	};

	static glm::vec3 normals[] = {
		{0.000000, 0.776360, -0.630238},   {0.000000, 0.594348, -0.804163},
		{0.548967, 0.548967, -0.630238},   {0.420270, 0.420270, -0.804163},
		{0.776360, 0.000000, -0.630238},   {0.594378, 0.000000, -0.804163},
		{0.548967, -0.548967, -0.630238},  {0.420270, -0.420270, -0.804163},
		{0.000000, -0.776360, -0.630238},  {0.000000, -0.594378, -0.804163},
		{-0.548967, -0.548967, -0.630238}, {-0.420270, -0.420270, -0.804163},
		{-0.776360, 0.000000, -0.630238},  {-0.594378, 0.000000, -0.804163},
		{-0.548967, 0.548967, -0.630238},  {-0.420270, 0.420270, -0.804163},
		{0.000000, 0.843226, -0.537492},   {0.596271, 0.596271, -0.537492},
		{0.843226, 0.000000, -0.537492},   {0.596271, -0.596271, -0.537492},
		{0.000000, -0.843226, -0.537492},  {-0.596271, -0.596271, -0.537492},
		{-0.843226, 0.000000, -0.537492},  {-0.596271, 0.596271, -0.537492},
		{0.000000, 0.000000, 1.000000},
	};

	static int indices[] = {
		1,  3,  2,  3,  5,  4,  5,  7,  6,  7,  9,  8,  9,  11, 10, 11, 13, 12, 5,  18, 19, 15, 1,
		0,  13, 15, 14, 6,  10, 14, 11, 21, 22, 7,  19, 20, 13, 22, 23, 3,  17, 18, 9,  20, 21, 15,
		23, 16, 1,  16, 17, 23, 22, 24, 21, 20, 24, 19, 18, 24, 17, 16, 24, 16, 23, 24, 22, 21, 24,
		20, 19, 24, 18, 17, 24, 0,  1,  2,  2,  3,  4,  4,  5,  6,  6,  7,  8,  8,  9,  10, 10, 11,
		12, 7,  5,  19, 14, 15, 0,  12, 13, 14, 14, 0,  2,  2,  4,  6,  6,  8,  10, 10, 12, 14, 14,
		2,  6,  13, 11, 22, 9,  7,  20, 15, 13, 23, 5,  3,  18, 11, 9,  21, 1,  15, 16, 3,  1,  17,
	};
}
namespace cube_n {

	static const glm::vec3 verts[] = {
		{1.000000, 1.000000, -1.000000},
		{1.000000, -1.000000, -1.000000},
		{-1.000000, -1.000000, -1.000000},
		{-1.000000, 1.000000, -1.000000},
		{1.000000, 1.000000, 1.000000},
		{0.999999, -1.000001, 1.000000},
		{-1.000000, -1.000000, 1.000000},
		{-1.000000, 1.000000, 1.000000},
	};

	static const glm::vec3 normals[] = {
		{0.577349, 0.577349, -0.577349},
		{0.577349, -0.577349, -0.577349},
		{-0.577349, -0.577349, -0.577349},
		{-0.577349, 0.577349, -0.577349},
		{0.577349, 0.577349, 0.577349},
		{0.577349, -0.577349, 0.577349},
		{-0.577349, -0.577349, 0.577349},
		{-0.577349, 0.577349, 0.577349},
	};

	static const int indices[] = {
		1, 2, 3, 7, 6, 5, 4, 5, 1, 5, 6, 2, 2, 6, 7, 0, 3, 7,
		0, 1, 3, 4, 7, 5, 0, 4, 1, 1, 5, 2, 3, 2, 7, 4, 0, 7,
	};
}

namespace dial_n {
	static const glm::vec3 verts[] = {
		{1.034000, 0.000000, 0.000000},    {1.017000, 0.000000, 0.029445},
		{0.983000, 0.000000, 0.029445},    {0.966000, 0.000000, 0.000000},
		{0.983000, 0.000000, -0.029445},   {1.017000, 0.000000, -0.029445},
		{1.014132, 0.201723, 0.000000},    {0.997459, 0.198407, 0.029445},
		{0.964112, 0.191774, 0.029445},    {0.947439, 0.188457, 0.000000},
		{0.964112, 0.191774, -0.029445},   {0.997459, 0.198407, -0.029445},
		{0.955292, 0.395695, 0.000000},    {0.939586, 0.389189, 0.029445},
		{0.908174, 0.376178, 0.029445},    {0.892468, 0.369672, 0.000000},
		{0.908174, 0.376178, -0.029445},   {0.939586, 0.389189, -0.029445},
		{0.859740, 0.574460, 0.000000},    {0.845605, 0.565015, 0.029445},
		{0.817335, 0.546126, 0.029445},    {0.803200, 0.536681, 0.000000},
		{0.817335, 0.546126, -0.029445},   {0.845605, 0.565015, -0.029445},
		{0.731148, 0.731148, 0.000000},    {0.719128, 0.719128, 0.029445},
		{0.695086, 0.695086, 0.029445},    {0.683065, 0.683065, 0.000000},
		{0.695086, 0.695086, -0.029445},   {0.719128, 0.719128, -0.029445},
		{0.574460, 0.859740, 0.000000},    {0.565015, 0.845605, 0.029445},
		{0.546125, 0.817335, 0.029445},    {0.536681, 0.803200, 0.000000},
		{0.546125, 0.817335, -0.029445},   {0.565015, 0.845605, -0.029445},
		{0.395695, 0.955291, 0.000000},    {0.389189, 0.939585, 0.029445},
		{0.376178, 0.908173, 0.029445},    {0.369672, 0.892467, 0.000000},
		{0.376178, 0.908173, -0.029445},   {0.389189, 0.939585, -0.029445},
		{0.201724, 1.014132, 0.000000},    {0.198407, 0.997459, 0.029445},
		{0.191774, 0.964112, 0.029445},    {0.188457, 0.947439, 0.000000},
		{0.191774, 0.964112, -0.029445},   {0.198407, 0.997459, -0.029445},
		{0.000000, 1.034000, 0.000000},    {0.000000, 1.017000, 0.029445},
		{0.000000, 0.983000, 0.029445},    {0.000000, 0.966000, 0.000000},
		{0.000000, 0.983000, -0.029445},   {0.000000, 1.017000, -0.029445},
		{-0.201723, 1.014132, 0.000000},   {-0.198407, 0.997459, 0.029445},
		{-0.191774, 0.964112, 0.029445},   {-0.188457, 0.947439, 0.000000},
		{-0.191774, 0.964112, -0.029445},  {-0.198407, 0.997459, -0.029445},
		{-0.395695, 0.955291, 0.000000},   {-0.389189, 0.939585, 0.029445},
		{-0.376178, 0.908174, 0.029445},   {-0.369672, 0.892468, 0.000000},
		{-0.376178, 0.908174, -0.029445},  {-0.389189, 0.939585, -0.029445},
		{-0.574459, 0.859740, 0.000000},   {-0.565015, 0.845605, 0.029445},
		{-0.546125, 0.817335, 0.029445},   {-0.536681, 0.803200, 0.000000},
		{-0.546125, 0.817335, -0.029445},  {-0.565015, 0.845605, -0.029445},
		{-0.731149, 0.731148, 0.000000},   {-0.719128, 0.719127, 0.029445},
		{-0.695086, 0.695086, 0.029445},   {-0.683065, 0.683065, 0.000000},
		{-0.695086, 0.695086, -0.029445},  {-0.719128, 0.719127, -0.029445},
		{-0.859740, 0.574460, 0.000000},   {-0.845604, 0.565015, 0.029445},
		{-0.817335, 0.546126, 0.029445},   {-0.803200, 0.536681, 0.000000},
		{-0.817335, 0.546126, -0.029445},  {-0.845604, 0.565015, -0.029445},
		{-0.955291, 0.395695, 0.000000},   {-0.939585, 0.389189, 0.029445},
		{-0.908173, 0.376178, 0.029445},   {-0.892468, 0.369672, 0.000000},
		{-0.908173, 0.376178, -0.029445},  {-0.939585, 0.389189, -0.029445},
		{-1.014132, 0.201723, 0.000000},   {-0.997459, 0.198407, 0.029445},
		{-0.964112, 0.191774, 0.029445},   {-0.947439, 0.188457, 0.000000},
		{-0.964112, 0.191774, -0.029445},  {-0.997459, 0.198407, -0.029445},
		{-1.034000, 0.000000, 0.000000},   {-1.017000, 0.000000, 0.029445},
		{-0.983000, 0.000000, 0.029445},   {-0.966000, 0.000000, 0.000000},
		{-0.983000, 0.000000, -0.029445},  {-1.017000, 0.000000, -0.029445},
		{-1.014132, -0.201723, 0.000000},  {-0.997459, -0.198407, 0.029445},
		{-0.964112, -0.191774, 0.029445},  {-0.947439, -0.188457, 0.000000},
		{-0.964112, -0.191774, -0.029445}, {-0.997459, -0.198407, -0.029445},
		{-0.955292, -0.395694, 0.000000},  {-0.939586, -0.389189, 0.029445},
		{-0.908174, -0.376177, 0.029445},  {-0.892468, -0.369672, 0.000000},
		{-0.908174, -0.376177, -0.029445}, {-0.939586, -0.389189, -0.029445},
		{-0.859740, -0.574460, 0.000000},  {-0.845604, -0.565015, 0.029445},
		{-0.817335, -0.546126, 0.029445},  {-0.803200, -0.536681, 0.000000},
		{-0.817335, -0.546126, -0.029445}, {-0.845604, -0.565015, -0.029445},
		{-0.731149, -0.731148, 0.000000},  {-0.719128, -0.719127, 0.029445},
		{-0.695086, -0.695086, 0.029445},  {-0.683065, -0.683065, 0.000000},
		{-0.695086, -0.695086, -0.029445}, {-0.719128, -0.719127, -0.029445},
		{-0.574460, -0.859739, 0.000000},  {-0.565015, -0.845604, 0.029445},
		{-0.546126, -0.817334, 0.029445},  {-0.536681, -0.803199, 0.000000},
		{-0.546126, -0.817334, -0.029445}, {-0.565015, -0.845604, -0.029445},
		{-0.395695, -0.955291, 0.000000},  {-0.389189, -0.939585, 0.029445},
		{-0.376178, -0.908174, 0.029445},  {-0.369672, -0.892468, 0.000000},
		{-0.376178, -0.908174, -0.029445}, {-0.389189, -0.939585, -0.029445},
		{-0.201724, -1.014132, 0.000000},  {-0.198407, -0.997459, 0.029445},
		{-0.191774, -0.964112, 0.029445},  {-0.188458, -0.947438, 0.000000},
		{-0.191774, -0.964112, -0.029445}, {-0.198407, -0.997459, -0.029445},
		{0.000000, -1.034000, 0.000000},   {0.000000, -1.017000, 0.029445},
		{0.000000, -0.983000, 0.029445},   {0.000000, -0.966000, 0.000000},
		{0.000000, -0.983000, -0.029445},  {0.000000, -1.017000, -0.029445},
		{0.201723, -1.014132, 0.000000},   {0.198407, -0.997459, 0.029445},
		{0.191773, -0.964112, 0.029445},   {0.188457, -0.947439, 0.000000},
		{0.191773, -0.964112, -0.029445},  {0.198407, -0.997459, -0.029445},
		{0.395695, -0.955291, 0.000000},   {0.389189, -0.939585, 0.029445},
		{0.376178, -0.908173, 0.029445},   {0.369672, -0.892467, 0.000000},
		{0.376178, -0.908173, -0.029445},  {0.389189, -0.939585, -0.029445},
		{0.574460, -0.859740, 0.000000},   {0.565015, -0.845605, 0.029445},
		{0.546125, -0.817335, 0.029445},   {0.536681, -0.803200, 0.000000},
		{0.546125, -0.817335, -0.029445},  {0.565015, -0.845605, -0.029445},
		{0.731148, -0.731149, 0.000000},   {0.719127, -0.719128, 0.029445},
		{0.695086, -0.695086, 0.029445},   {0.683065, -0.683066, 0.000000},
		{0.695086, -0.695086, -0.029445},  {0.719127, -0.719128, -0.029445},
		{0.859740, -0.574460, 0.000000},   {0.845605, -0.565015, 0.029445},
		{0.817335, -0.546126, 0.029445},   {0.803200, -0.536681, 0.000000},
		{0.817335, -0.546126, -0.029445},  {0.845605, -0.565015, -0.029445},
		{0.955291, -0.395695, 0.000000},   {0.939585, -0.389189, 0.029445},
		{0.908173, -0.376178, 0.029445},   {0.892467, -0.369673, 0.000000},
		{0.908173, -0.376178, -0.029445},  {0.939585, -0.389189, -0.029445},
		{1.014132, -0.201723, 0.000000},   {0.997459, -0.198407, 0.029445},
		{0.964112, -0.191774, 0.029445},   {0.947439, -0.188457, 0.000000},
		{0.964112, -0.191774, -0.029445},  {0.997459, -0.198407, -0.029445},
	};

	static const glm::vec3 normals[] = {
		{1.000000, 0.000000, 0.000000},    {0.522691, 0.000000, 0.852504},
		{-0.475845, 0.000000, 0.879513},   {-1.000000, 0.000000, 0.000000},
		{-0.475845, 0.000000, -0.879513},  {0.522691, 0.000000, -0.852504},
		{0.980773, 0.195074, 0.000000},    {0.512650, 0.101962, 0.852504},
		{-0.466689, -0.092807, 0.879513},  {-0.980773, -0.195074, 0.000000},
		{-0.466689, -0.092807, -0.879513}, {0.512650, 0.101962, -0.852504},
		{0.923856, 0.382672, 0.000000},    {0.482894, 0.200018, 0.852504},
		{-0.439619, -0.182073, 0.879513},  {-0.923856, -0.382672, 0.000000},
		{-0.439619, -0.182073, -0.879513}, {0.482894, 0.200018, -0.852504},
		{0.831446, 0.555559, 0.000000},    {0.434614, 0.290384, 0.852504},
		{-0.395642, -0.264351, 0.879513},  {-0.831446, -0.555559, 0.000000},
		{-0.395642, -0.264351, -0.879513}, {0.434614, 0.290384, -0.852504},
		{0.707083, 0.707083, 0.000000},    {0.369610, 0.369610, 0.852504},
		{-0.336467, -0.336467, 0.879513},  {-0.707083, -0.707083, 0.000000},
		{-0.336467, -0.336467, -0.879513}, {0.369610, 0.369610, -0.852504},
		{0.555559, 0.831446, 0.000000},    {0.290384, 0.434614, 0.852504},
		{-0.264351, -0.395642, 0.879513},  {-0.555559, -0.831446, 0.000000},
		{-0.264351, -0.395642, -0.879513}, {0.290384, 0.434614, -0.852504},
		{0.382672, 0.923856, 0.000000},    {0.200018, 0.482894, 0.852504},
		{-0.182073, -0.439619, 0.879513},  {-0.382672, -0.923856, 0.000000},
		{-0.182073, -0.439619, -0.879513}, {0.200018, 0.482894, -0.852504},
		{0.195074, 0.980773, 0.000000},    {0.101962, 0.512650, 0.852504},
		{-0.092807, -0.466689, 0.879513},  {-0.195074, -0.980773, 0.000000},
		{-0.092807, -0.466689, -0.879513}, {0.101962, 0.512650, -0.852504},
		{0.000000, 1.000000, 0.000000},    {0.000000, 0.522691, 0.852504},
		{0.000000, -0.475845, 0.879513},   {0.000000, -1.000000, 0.000000},
		{0.000000, -0.475845, -0.879513},  {0.000000, 0.522691, -0.852504},
		{-0.195074, 0.980773, 0.000000},   {-0.101962, 0.512650, 0.852504},
		{0.092807, -0.466689, 0.879513},   {0.195074, -0.980773, 0.000000},
		{0.092807, -0.466689, -0.879513},  {-0.101962, 0.512650, -0.852504},
		{-0.382672, 0.923856, 0.000000},   {-0.200018, 0.482894, 0.852504},
		{0.182073, -0.439619, 0.879513},   {0.382672, -0.923856, 0.000000},
		{0.182073, -0.439619, -0.879513},  {-0.200018, 0.482894, -0.852504},
		{-0.555559, 0.831446, 0.000000},   {-0.290384, 0.434614, 0.852504},
		{0.264351, -0.395642, 0.879513},   {0.555559, -0.831446, 0.000000},
		{0.264351, -0.395642, -0.879513},  {-0.290384, 0.434614, -0.852504},
		{-0.707083, 0.707083, 0.000000},   {-0.369610, 0.369610, 0.852504},
		{0.336467, -0.336467, 0.879513},   {0.707083, -0.707083, 0.000000},
		{0.336467, -0.336467, -0.879513},  {-0.369610, 0.369610, -0.852504},
		{-0.831446, 0.555559, 0.000000},   {-0.434614, 0.290384, 0.852504},
		{0.395642, -0.264351, 0.879513},   {0.831446, -0.555559, 0.000000},
		{0.395642, -0.264351, -0.879513},  {-0.434614, 0.290384, -0.852504},
		{-0.923856, 0.382672, 0.000000},   {-0.482894, 0.200018, 0.852504},
		{0.439619, -0.182073, 0.879513},   {0.923856, -0.382672, 0.000000},
		{0.439619, -0.182073, -0.879513},  {-0.482894, 0.200018, -0.852504},
		{-0.980773, 0.195074, 0.000000},   {-0.512650, 0.101962, 0.852504},
		{0.466689, -0.092807, 0.879513},   {0.980773, -0.195074, 0.000000},
		{0.466689, -0.092807, -0.879513},  {-0.512650, 0.101962, -0.852504},
		{-1.000000, 0.000000, 0.000000},   {-0.522691, 0.000000, 0.852504},
		{0.475845, 0.000000, 0.879513},    {1.000000, 0.000000, 0.000000},
		{0.475845, 0.000000, -0.879513},   {-0.522691, 0.000000, -0.852504},
		{-0.980773, -0.195074, 0.000000},  {-0.512650, -0.101962, 0.852504},
		{0.466689, 0.092807, 0.879513},    {0.980773, 0.195074, 0.000000},
		{0.466689, 0.092807, -0.879513},   {-0.512650, -0.101962, -0.852504},
		{-0.923856, -0.382672, 0.000000},  {-0.482894, -0.200018, 0.852504},
		{0.439619, 0.182073, 0.879513},    {0.923856, 0.382672, 0.000000},
		{0.439619, 0.182073, -0.879513},   {-0.482894, -0.200018, -0.852504},
		{-0.831446, -0.555559, 0.000000},  {-0.434614, -0.290384, 0.852504},
		{0.395642, 0.264351, 0.879513},    {0.831446, 0.555559, 0.000000},
		{0.395642, 0.264351, -0.879513},   {-0.434614, -0.290384, -0.852504},
		{-0.707083, -0.707083, 0.000000},  {-0.369610, -0.369610, 0.852504},
		{0.336467, 0.336467, 0.879513},    {0.707083, 0.707083, 0.000000},
		{0.336467, 0.336467, -0.879513},   {-0.369610, -0.369610, -0.852504},
		{-0.555559, -0.831446, 0.000000},  {-0.290384, -0.434614, 0.852504},
		{0.264351, 0.395642, 0.879513},    {0.555559, 0.831446, 0.000000},
		{0.264351, 0.395642, -0.879513},   {-0.290384, -0.434614, -0.852504},
		{-0.382672, -0.923856, 0.000000},  {-0.200018, -0.482894, 0.852504},
		{0.182073, 0.439619, 0.879513},    {0.382672, 0.923856, 0.000000},
		{0.182073, 0.439619, -0.879513},   {-0.200018, -0.482894, -0.852504},
		{-0.195074, -0.980773, 0.000000},  {-0.101962, -0.512650, 0.852504},
		{0.092807, 0.466689, 0.879513},    {0.195074, 0.980773, 0.000000},
		{0.092807, 0.466689, -0.879513},   {-0.101962, -0.512650, -0.852504},
		{0.000000, -1.000000, 0.000000},   {0.000000, -0.522691, 0.852504},
		{0.000000, 0.475845, 0.879513},    {0.000000, 1.000000, 0.000000},
		{0.000000, 0.475845, -0.879513},   {0.000000, -0.522691, -0.852504},
		{0.195074, -0.980773, 0.000000},   {0.101962, -0.512650, 0.852504},
		{-0.092807, 0.466689, 0.879513},   {-0.195074, 0.980773, 0.000000},
		{-0.092807, 0.466689, -0.879513},  {0.101962, -0.512650, -0.852504},
		{0.382672, -0.923856, 0.000000},   {0.200018, -0.482894, 0.852504},
		{-0.182073, 0.439619, 0.879513},   {-0.382672, 0.923856, 0.000000},
		{-0.182073, 0.439619, -0.879513},  {0.200018, -0.482894, -0.852504},
		{0.555559, -0.831446, 0.000000},   {0.290384, -0.434614, 0.852504},
		{-0.264351, 0.395642, 0.879513},   {-0.555559, 0.831446, 0.000000},
		{-0.264351, 0.395642, -0.879513},  {0.290384, -0.434614, -0.852504},
		{0.707083, -0.707083, 0.000000},   {0.369610, -0.369610, 0.852504},
		{-0.336467, 0.336467, 0.879513},   {-0.707083, 0.707083, 0.000000},
		{-0.336467, 0.336467, -0.879513},  {0.369610, -0.369610, -0.852504},
		{0.831446, -0.555559, 0.000000},   {0.434614, -0.290384, 0.852504},
		{-0.395642, 0.264351, 0.879513},   {-0.831446, 0.555559, 0.000000},
		{-0.395642, 0.264351, -0.879513},  {0.434614, -0.290384, -0.852504},
		{0.923856, -0.382672, 0.000000},   {0.482894, -0.200018, 0.852504},
		{-0.439619, 0.182073, 0.879513},   {-0.923856, 0.382672, 0.000000},
		{-0.439619, 0.182073, -0.879513},  {0.482894, -0.200018, -0.852504},
		{0.980773, -0.195074, 0.000000},   {0.512650, -0.101962, 0.852504},
		{-0.466689, 0.092807, 0.879513},   {-0.980773, 0.195074, 0.000000},
		{-0.466689, 0.092807, -0.879513},  {0.512650, -0.101962, -0.852504},
	};

	static const int indices[] = {
		6,   7,   1,   7,   8,   2,   8,   9,   3,   9,   10,  4,   10,  11,  5,   5,   11,  6,   12,
		13,  7,   13,  14,  8,   14,  15,  9,   15,  16,  10,  16,  17,  11,  11,  17,  12,  18,  19,
		13,  13,  19,  20,  20,  21,  15,  15,  21,  22,  22,  23,  17,  17,  23,  18,  24,  25,  19,
		19,  25,  26,  26,  27,  21,  21,  27,  28,  28,  29,  23,  23,  29,  24,  30,  31,  25,  25,
		31,  32,  26,  32,  33,  27,  33,  34,  34,  35,  29,  29,  35,  30,  36,  37,  31,  31,  37,
		38,  38,  39,  33,  39,  40,  34,  40,  41,  35,  35,  41,  36,  36,  42,  43,  43,  44,  38,
		44,  45,  39,  45,  46,  40,  46,  47,  41,  47,  42,  36,  48,  49,  43,  49,  50,  44,  50,
		51,  45,  51,  52,  46,  52,  53,  47,  47,  53,  48,  54,  55,  49,  49,  55,  56,  50,  56,
		57,  57,  58,  52,  58,  59,  53,  53,  59,  54,  60,  61,  55,  55,  61,  62,  56,  62,  63,
		63,  64,  58,  64,  65,  59,  59,  65,  60,  66,  67,  61,  61,  67,  68,  68,  69,  63,  69,
		70,  64,  70,  71,  65,  71,  66,  60,  72,  73,  67,  73,  74,  68,  68,  74,  75,  75,  76,
		70,  76,  77,  71,  71,  77,  72,  78,  79,  73,  79,  80,  74,  74,  80,  81,  81,  82,  76,
		82,  83,  77,  83,  78,  72,  78,  84,  85,  85,  86,  80,  80,  86,  87,  87,  88,  82,  82,
		88,  89,  89,  84,  78,  90,  91,  85,  91,  92,  86,  86,  92,  93,  93,  94,  88,  88,  94,
		95,  95,  90,  84,  96,  97,  91,  97,  98,  92,  98,  99,  93,  99,  100, 94,  100, 101, 95,
		101, 96,  90,  102, 103, 97,  103, 104, 98,  104, 105, 99,  99,  105, 106, 106, 107, 101, 101,
		107, 102, 108, 109, 103, 103, 109, 110, 110, 111, 105, 105, 111, 112, 112, 113, 107, 107, 113,
		108, 114, 115, 109, 115, 116, 110, 116, 117, 111, 111, 117, 118, 112, 118, 119, 113, 119, 114,
		114, 120, 121, 121, 122, 116, 122, 123, 117, 117, 123, 124, 124, 125, 119, 125, 120, 114, 126,
		127, 121, 121, 127, 128, 128, 129, 123, 123, 129, 130, 130, 131, 125, 125, 131, 126, 132, 133,
		127, 133, 134, 128, 128, 134, 135, 135, 136, 130, 136, 137, 131, 131, 137, 132, 132, 138, 139,
		133, 139, 140, 134, 140, 141, 141, 142, 136, 142, 143, 137, 143, 138, 132, 138, 144, 145, 139,
		145, 146, 146, 147, 141, 141, 147, 148, 148, 149, 143, 149, 144, 138, 144, 150, 151, 151, 152,
		146, 146, 152, 153, 153, 154, 148, 154, 155, 149, 155, 150, 144, 156, 157, 151, 151, 157, 158,
		158, 159, 153, 159, 160, 154, 160, 161, 155, 155, 161, 156, 156, 162, 163, 163, 164, 158, 158,
		164, 165, 165, 166, 160, 160, 166, 167, 167, 162, 156, 162, 168, 169, 169, 170, 164, 164, 170,
		171, 165, 171, 172, 166, 172, 173, 173, 168, 162, 174, 175, 169, 175, 176, 170, 170, 176, 177,
		177, 178, 172, 172, 178, 179, 173, 179, 174, 174, 180, 181, 181, 182, 176, 176, 182, 183, 183,
		184, 178, 178, 184, 185, 179, 185, 180, 186, 187, 181, 187, 188, 182, 188, 189, 183, 183, 189,
		190, 190, 191, 185, 191, 186, 180, 0,   1,   187, 1,   2,   188, 2,   3,   189, 3,   4,   190,
		190, 4,   5,   191, 5,   0,   0,   6,   1,   1,   7,   2,   2,   8,   3,   3,   9,   4,   4,
		10,  5,   0,   5,   6,   6,   12,  7,   7,   13,  8,   8,   14,  9,   9,   15,  10,  10,  16,
		11,  6,   11,  12,  12,  18,  13,  14,  13,  20,  14,  20,  15,  16,  15,  22,  16,  22,  17,
		12,  17,  18,  18,  24,  19,  20,  19,  26,  20,  26,  21,  22,  21,  28,  22,  28,  23,  18,
		23,  24,  24,  30,  25,  26,  25,  32,  27,  26,  33,  28,  27,  34,  28,  34,  29,  24,  29,
		30,  30,  36,  31,  32,  31,  38,  32,  38,  33,  33,  39,  34,  34,  40,  35,  30,  35,  36,
		37,  36,  43,  37,  43,  38,  38,  44,  39,  39,  45,  40,  40,  46,  41,  41,  47,  36,  42,
		48,  43,  43,  49,  44,  44,  50,  45,  45,  51,  46,  46,  52,  47,  42,  47,  48,  48,  54,
		49,  50,  49,  56,  51,  50,  57,  51,  57,  52,  52,  58,  53,  48,  53,  54,  54,  60,  55,
		56,  55,  62,  57,  56,  63,  57,  63,  58,  58,  64,  59,  54,  59,  60,  60,  66,  61,  62,
		61,  68,  62,  68,  63,  63,  69,  64,  64,  70,  65,  65,  71,  60,  66,  72,  67,  67,  73,
		68,  69,  68,  75,  69,  75,  70,  70,  76,  71,  66,  71,  72,  72,  78,  73,  73,  79,  74,
		75,  74,  81,  75,  81,  76,  76,  82,  77,  77,  83,  72,  79,  78,  85,  79,  85,  80,  81,
		80,  87,  81,  87,  82,  83,  82,  89,  83,  89,  78,  84,  90,  85,  85,  91,  86,  87,  86,
		93,  87,  93,  88,  89,  88,  95,  89,  95,  84,  90,  96,  91,  91,  97,  92,  92,  98,  93,
		93,  99,  94,  94,  100, 95,  95,  101, 90,  96,  102, 97,  97,  103, 98,  98,  104, 99,  100,
		99,  106, 100, 106, 101, 96,  101, 102, 102, 108, 103, 104, 103, 110, 104, 110, 105, 106, 105,
		112, 106, 112, 107, 102, 107, 108, 108, 114, 109, 109, 115, 110, 110, 116, 111, 112, 111, 118,
		113, 112, 119, 108, 113, 114, 115, 114, 121, 115, 121, 116, 116, 122, 117, 118, 117, 124, 118,
		124, 119, 119, 125, 114, 120, 126, 121, 122, 121, 128, 122, 128, 123, 124, 123, 130, 124, 130,
		125, 120, 125, 126, 126, 132, 127, 127, 133, 128, 129, 128, 135, 129, 135, 130, 130, 136, 131,
		126, 131, 132, 133, 132, 139, 134, 133, 140, 135, 134, 141, 135, 141, 136, 136, 142, 137, 137,
		143, 132, 139, 138, 145, 140, 139, 146, 140, 146, 141, 142, 141, 148, 142, 148, 143, 143, 149,
		138, 145, 144, 151, 145, 151, 146, 147, 146, 153, 147, 153, 148, 148, 154, 149, 149, 155, 144,
		150, 156, 151, 152, 151, 158, 152, 158, 153, 153, 159, 154, 154, 160, 155, 150, 155, 156, 157,
		156, 163, 157, 163, 158, 159, 158, 165, 159, 165, 160, 161, 160, 167, 161, 167, 156, 163, 162,
		169, 163, 169, 164, 165, 164, 171, 166, 165, 172, 167, 166, 173, 167, 173, 162, 168, 174, 169,
		169, 175, 170, 171, 170, 177, 171, 177, 172, 173, 172, 179, 168, 173, 174, 175, 174, 181, 175,
		181, 176, 177, 176, 183, 177, 183, 178, 179, 178, 185, 174, 179, 180, 180, 186, 181, 181, 187,
		182, 182, 188, 183, 184, 183, 190, 184, 190, 185, 185, 191, 180, 186, 0,   187, 187, 1,   188,
		188, 2,   189, 189, 3,   190, 191, 190, 5,   186, 191, 0,
	};
}


GizmoGeomInfo wm_gizmo_geom_data_arrow = {
	/*nverts*/ 25,
	/*ntris*/ 46,
	/*verts*/ arrow_n::verts,
	/*normals*/ arrow_n::normals,
	/*indices*/ arrow_n::indices,
};

GizmoGeomInfo wm_gizmo_geom_data_cube = {
	/*nverts*/ 8,
	/*ntris*/ 12,
	/*verts*/ cube_n::verts,
	/*normals*/ cube_n::normals,
	/*indices*/ cube_n::indices,
};
GizmoGeomInfo wm_gizmo_geom_data_dial = {
	/*nverts*/ 192,
	/*ntris*/ 384,
	/*verts*/ dial_n::verts,
	/*normals*/dial_n::normals,
	/*indices*/dial_n::indices,
};

static std::string toStr(const njson& v, const std::string& des = "")
{
	std::string ret = des;
	if (v.is_null())
	{
		//ret = "";
	}
	else if (v.is_string())
	{
		ret = v.get<std::string>();
	}
	else
	{
		ret = md::trim(v.dump(), "\"");
	}
	return ret;
}
struct curl_data_t
{
	std::vector<char> data;
	std::atomic_int progress = 0;	// 进度字节数
	int all_size = 0;	// 总字节数
};
#include <vector>
int main()
{
#ifdef _DEBUG
	system("rd /s /q E:\\temcpp\\SymbolCache\\tcmp.pdb");
	system("rd /s /q E:\\temcpp\\SymbolCache\\cedit.pdb");
	system("rd /s /q E:\\temcpp\\SymbolCache\\p86.pdb");
#endif 
	auto app = new_app();

	glm::ivec2 ws = { 1280,800 };
	const char* wtitle = (char*)u8"窗口1";
	njson v = 0;
	auto ksfd = toStr(v);
#if 1
#if 1
	form_x* form0 = (form_x*)new_form(app, wtitle, ws.x, ws.y, -1, -1, 0);
	auto sdldev = form0->get_dev();		// 获取SDL渲染器的vk设备
	vkdg_cx* vkd = new_vkdg(&sdldev);	// 创建vk渲染器
	SDL_Texture* d3tex = 0;
	if (vkd) {
		int xk = 0;
		//load_gltf(vkd, R"(E:\code\nv\donut_examples\media\glTF-Sample-Assets\Models\BrainStem\glTF-Binary\BrainStem.glb)");
		load_gltf(vkd, R"(E:\app\tools\pnguo\out\bin\media\Bee.glb)");
		//load_gltf(vkd, R"(E:\model\realistic_palm_tree_10_free.glb)");
		load_gltf(vkd, R"(E:\model\pale_radiance_tree.glb)");
		//load_gltf(vkd, R"(E:\model\maple_trees.glb)");
		load_gltf(vkd, R"(E:\app\tools\pnguo\out\bin\media\Cauldron-Media\buster_drone\busterDrone.gltf)");

		//load_gltf(vkd, R"(E:\model\cube18.glb)");
		vkd->resize(800, 600);
		auto vr = vkd->get_vkimage(0);
		if (vr.vkimageptr)
		{
			auto tex = form0->new_texture(vr.size.x, vr.size.y, vr.vkimageptr, 1);// bgra纹理
			if (tex)
			{
				form0->set_texture_blend(tex, (int)BlendMode_e::normal, 0);
				form0->push_texture(tex, { 0,0,vr.size.x,vr.size.y }, { 100,100,vr.size.x,vr.size.y }, 0);
			}
		}
		//auto pipe = vkd->new_pipe("base3d.vert.glsl", "base3d.frag.glsl");
	}
	form0->up_cb = [=](float delta, int* ret)
		{
			vkd->update(form0->io);
			vkd->on_render();
			bool ks = false;
			if (ks && vkd) {
				vkd->save_fbo(0);
				stbi_write_png("temp/fbovkr.png", vkd->width, vkd->height, 4, vkd->dt.data(), 0);
			}
		};
	//form0->_focus_lost_hide = true;
	auto fontn = (char*)u8"新宋体,Segoe UI Emoji,Times New Roman,Malgun Gothic";
	auto ftc = app->font_ctx;
	static std::atomic_bool kinit = false;
	std::thread attt([=]() {
		do {
			xatlasAtlas* xa = xatlasCreate();
			layout_text_x ltx = {};
			ltx.set_ctx(ftc);
			ltx.add_familys(fontn, 0);
			kinit = true;

			text_path_t tp = {};
			auto gsp = ltx.get_shape(0, u8"爱", 60, &tp);// fontsize=0获取原始大小
			std::vector<glm::vec2> ms;
			if (tp.tv.empty())break;
			path_v pv;
			pv.set_data(tp.tv.data(), tp.tv.size());

			save_png_v(&pv, 1, "temp/cct3h.png", 1, 10);
			glm::dvec2 ad;
			pv.triangulate(8, 1, 1, 0, &ms, 0);
			if (ms.size())
			{
				stl3d_cx sc;
				sc.add(ms.data(), ms.size());
				auto fn = "temp/cct3h_cdt.stl";
				sc.save(fn, 0);
			}
			ms.clear();
			pv.triangulate(8, 1, 1, 0, &ms, 1);
			if (ms.size())
			{
				stl3d_cx sc;
				sc.add(ms.data(), ms.size());
				auto fn = "temp/cct3h_gr.stl";
				sc.save(fn, 0);
			}

			return;







			std::vector<mesh_triangle_cx> mv;
			gp::line_style_t et = { 3,6,1,0,{1,1} };
			gp::mesh3_mt tf3 = {};
			gp::mesh_mt tf4 = {};			// 四边形网络
			gp::mesh_mt tf5 = {};			// 四边形网络
			gp::mesh_mt tf6 = {};			// 四边形网络
			et.count = 6;
			et.type.x = 0;
			et.bottom_thickness = 0.8;
			//et.type.y = -1;
			et.thickness = 0.9;// 0为实心
			gp::build_line3d({ 1,1,0 }, { 10,10,0 }, { 6,5 }, &et, &tf4);
			et.type.x = 1;
			gp::build_line3d({ 1,9,0.5 }, { 10,1,0.5 }, { 3,3 }, &et, &tf5);
			et.type.x = 2;
			gp::build_line3d({ 1,2,0.5 }, { 10,12,0.5 }, { 5,3 }, &et, &tf6);
			std::string fns[] = {
				"a_not_b",		// 差集a-=b
				"b_not_a",		// 差集b-=a
				"union",		// 并集
				"intersection"	// 交集
			};
			{
				print_time aadk("bool mesh");
				make_boolean(&tf4, &tf5, mv, flags_b::A_NOT_B);
			}
#if 0
			{
				print_time aadk("bool mesh");
				make_boolean(&tf4, &tf5, mv, flags_b::B_NOT_A);

			}
			{
				print_time aadk("bool mesh");
				make_boolean(&tf4, &tf5, mv, flags_b::UNION);
			}
			{
				print_time aadk("bool mesh");
				make_boolean(&tf4, &tf5, mv, flags_b::INTERSECTION);
			}
#endif
			std::string fn = "temp/test_boolean_tf4.stl";
			mesh_save_stl(&tf4, fn.c_str());
			fn = "temp/test_boolean_tf5.stl";
			mesh_save_stl(&tf5, fn.c_str());
			fn = "temp/test_boolean_tf6.stl";
			mesh_save_stl(&tf6, fn.c_str());

			mesh_triangle_cx mta;
			mta.set_data(wm_gizmo_geom_data_arrow.verts, wm_gizmo_geom_data_arrow.nverts, (uint32_t*)wm_gizmo_geom_data_arrow.indices, wm_gizmo_geom_data_arrow.ntris * 3);
			fn = "temp/test_arrow.stl";
			mesh_save_stl(&mta, fn.c_str());
			mta.set_data(wm_gizmo_geom_data_cube.verts, wm_gizmo_geom_data_cube.nverts, (uint32_t*)wm_gizmo_geom_data_cube.indices, wm_gizmo_geom_data_cube.ntris * 3);
			fn = "temp/test_cube.stl";
			mesh_save_stl(&mta, fn.c_str());
			mta.set_data(wm_gizmo_geom_data_dial.verts, wm_gizmo_geom_data_dial.nverts, (uint32_t*)wm_gizmo_geom_data_dial.indices, wm_gizmo_geom_data_dial.ntris * 3);
			fn = "temp/test_dial.stl";
			mesh_save_stl(&mta, fn.c_str());

#if 0
			gp::mesh_mt tc4 = {};
			glm::dvec3 v3[] = {
				{ -5, -5, 5}, // 0
				{5, -5, 5 }, // 1
				{5, 5, 5	}, //2
				{-5, 5, 5}, //3
				{-5, -5, -5}, //4
				{5, -5, -5}, //5
				{5, 5, -5}, //6
				{-5, 5, -5 }//7
			};
			tc4.add_vertex(v3, 8);
			tc4.face_indices = {
				0, 1, 2, 3, //0
				7, 6, 5, 4, //1
				1, 5, 6, 2, //2
				0, 3, 7, 4, //3
				3, 2, 6, 7, //4
				4, 5, 1, 0 //5
			};
			tc4.face_sizes = { 4, 4, 4, 4, 4, 4 };// 四边形
			gp::mesh_mt tv4 = {};
			{
				glm::dvec3 v3[] = {
					{  -20, -4, 0}, //0
					{0, 20, 20}, //1
					{20, -4, 0}, //2
					{0, 20, -20}, //3 
				};
				tv4.add_vertex(v3, 4);
				tv4.face_indices = {
					 0, 1, 2, //0
					 0, 2, 3 //1
				};
				tv4.face_sizes = { 3,3 };// 两个三角面
			}


			make_boolean(&tc4, &tv4, mv, flags_b::INTERSECTION);
			if (mv.empty())
				make_boolean(&tc4, &tv4, mv, flags_b::UNION);
#endif
			if (mv.size())
			{
				for (int i = 0; i < mv.size(); i++) {
					auto& it = mv[i];
					std::string fn = "temp/test_boolean" + fns[i] + ".stl";
					mesh_save_stl(&it, fn.c_str());
				}
			}

		} while (0);
		});
	attt.detach();
	while (!kinit) {
		Sleep(1);
	}
	menu_cx* mc = new menu_cx();	// 菜单管理
	mc->set_main(form0);
	mc->add_familys(fontn);


	std::vector<std::string> mvs = { (char*)u8"🍇测试菜单1g",(char*)u8"🍑菜单",(char*)u8"🍍菜单1" };
	std::vector<std::string> mvs1 = { (char*)u8"🍇子菜单",(char*)u8"🍑菜单2",(char*)u8"🍍菜单12" };
	int cidx = 1;
	// 创建菜单
	auto pm31 = mc->new_menu(-1, 22, mvs1, [=](mitem_t* pm, int type, int idx)
		{
			if (type)
			{
				pm->hide(true);	// 点击隐藏
				printf("click:%d\t%d\n", type, idx);
			}
			else
				printf("move:%d\t%d\n", type, idx);
		});
	auto pm3 = mc->new_menu(-1, 22, mvs, [=](mitem_t* pm, int type, int idx)
		{
			if (type)
			{
				if (idx != cidx)
					pm->hide(true);	// 点击隐藏
				printf("click:%d\t%d\n", type, idx);
			}
			else
			{
				if (idx == cidx)
					pm31->show(pm->get_idx_pos(idx));// 显示子菜单
				else
					pm31->hide(false);
				printf("move:%d\t%d\n", type, idx);
			}
		});
	pm31->parent = pm3;
	pm3->show({ 100,100 }); // 显示菜单
	// 提示窗口
	//form_x* new_form_tooltip(form_x * parent, int width, int height);

	//form_x* form1 = 0;// (form_x*)call_data((int)cdtype_e::new_form, &ptf);
	//form_x* form0 =  app->new_form_renderer(ptf.title, ptf.size, ptf.flags,ptf.has_renderer);
	//form1->set_alpha(true);
	////form0->set_alpha(false);
	//form0->on_close_cb = [=]() {
	//	return 0;// 返回1关闭窗口，返回0隐藏窗口
	//	};
	//form0->enable_window(0);
	auto vkdev = form0->get_dev();
	bool bindless = form0->has_variable();
	int cpun = call_data((int)cdtype_e::cpu_count, 0);
	auto pw = form0;
	printf((char*)u8"启动\n cpu核心数量:%d\n", cpun);
#endif
	auto mainmenu = new plane_cx();
	auto pl1 = new plane_cx();
	auto pl2 = new plane_cx();
	auto pl3 = new plane_cx();
	auto pl4 = new plane_cx();
	auto listp = new listview_cx();
	pl2->_lms = { 6,6 };
	uint32_t pbc = 0x80121212;

	pl1->set_border({ 0x80ff802C,1,5,pbc });
	pl2->set_border({ 0x80ff802C,1,5,pbc });
	pl3->set_border({ 0x80ff802C,1,5 ,pbc });
	pw->bind(mainmenu, 1);	// 绑定到窗口
	pw->bind(pl3);	// 绑定到窗口
	pw->bind(pl2);	// 绑定到窗口
	pw->bind(pl1);	// 绑定到窗口
	pw->bind(pl4);
	pl2->visible = false;
	pl3->visible = false;
	mainmenu->set_rss(5);
	pl1->set_rss(5);
	pl2->set_rss(5);
	pl3->set_rss(5);
	pl4->set_rss(5);
	listp->set_rss(5);
	auto fontn2 = (char*)u8"Consolas,新宋体,Times New Roman";
	//fontn = (char*)u8"黑体,Segoe UI Emoji";
	//size_t add_familys(const char* familys, const char* style)
	mainmenu->add_familys(fontn, 0);
	pl1->add_familys(fontn, 0);
	pl1->add_familys(fontn2, 0);
	pl2->add_familys(fontn, 0);
	pl3->add_familys(fontn, 0);
	//pl2->_css.justify_content = flex_item::flex_align::ALIGN_SPACE_EVENLY;
	//pl4->visible = false;
	//pl3->visible = false;
	//pl2->visible = false;
	//pl1->visible = false;
	//listp->visible = false;
	{
		auto p = mainmenu;
		//p->draggable = true; //可拖动
		p->set_border({ 0,1,0,0xff000000 });
		// 主菜单
		std::vector<std::string> mvs = { (char*)u8"文件",(char*)u8"编辑",(char*)u8"视图",(char*)u8"工具",(char*)u8"帮助" };
		p->_lms = { 2,2 };
		p->fontsize = 16;
		p->set_size({ form0->get_size().x - 1,50 });
		p->set_pos({});
		glm::vec2 cs = { 1500,1600 };
		auto vs = p->get_size();

		p->set_view(vs, cs);
		for (auto& it : mvs)
		{
			auto cbt = p->add_cbutton(it.c_str(), { 60,26 }, (int)uType::info);
			cbt->effect = uTheme::light;
			cbt->hscroll = {};
			cbt->rounding = 0;
			cbt->light = 0.1;

			cbt->click_cb = [=](void* ptr, int clicks)
				{
					printf("%s\n", cbt->str.c_str());
				};
		}
	}

	{
		auto p = pl4;
		p->draggable = true; //可拖动
		p->add_familys(fontn, 0);
		p->_lms = { 6,6 };
		p->set_border({ 0x80ff802C,1,5 ,pbc });
		p->on_click_outer = [=](plane_cx* p, int state, int clicks) {p->visible = false; };
		p->fontsize = 26;
		p->set_size({ 500,600 });
		p->set_pos({ 200,10 });
		auto pss = p->get_size();
		int width = 10;
		int rcw = 8;
		{
			// 设置带滚动条
			p->set_scroll(width, rcw, { 0,0 });
			p->set_scroll_hide(1);
		}
		glm::vec2 cs = { 1500,1600 };
		auto vs = p->get_size();
		vs -= 22;
		p->set_view(vs, cs);


		flex_item root;
		auto ss = p->get_size();
		root.width = ss.x - 100;
		root.height = ss.y;
		root.justify_content = flex_item::flex_align::ALIGN_START;
		root.align_content = flex_item::flex_align::ALIGN_START;
		root.align_items = flex_item::flex_align::ALIGN_CENTER;
		root.wrap = flex_item::flex_wrap::WRAP;
		root.direction = flex_item::flex_direction::ROW;

		std::vector<glm::vec4> layouts = { 		 };
		glm::vec2 rsize = { root.width,root.height };
		flex_item* c = flexlayout(&root, layouts, {}, { 6,16 });
		div2_t* div = new div2_t();
		div->set_root({ 200,200,66,500 });
		div->set_root_style(0, root);
		//div->set_root_style(1, root);
		root.justify_content = flex_item::flex_align::ALIGN_END;
		root.direction = flex_item::flex_direction::COLUMN;
		root.align_content = flex_item::flex_align::ALIGN_START;
		div->set_root_style(2, root);
		root.align_content = flex_item::flex_align::ALIGN_START;
		div->set_root_style(3, root);
		div->add_child(2, { 60,60 });
		div->add_child(2, { 60,160 });
		div->add_child(2, { 60,60 });
		div->rcs[2].w = 500;
		div->rcs[3].w = 500;
		for (size_t i = 0; i < 8; i++)
		{
			div->add_child(3, { 60,20 });
		}
		{
			auto& cc = div->childs[2];
			div->c2.resize(cc.size());
			for (size_t i = 0; i < cc.size(); i++)
			{
				div->c2[i].grow = 1;// 320.0 / cc[i].w;
			}
		}
		div->layout();
		{
			//auto img = p->new_image2("E:\\tx\\03.gif");
			//auto imgsur = new_image_cr(img);
			//glm::vec2 ds = { img->width  ,img->height };
			//if (img->width + 100 > cs.x)
			//{
			//	cs.x = img->width + 100;
			//}
			//if (img->height + 100 > cs.y)
			//{
			//	cs.y = img->height + 100;
			//}
			p->set_view(vs, cs);

			auto gb2 = p->add_cbutton((char*)u8"🍑add", { 180,50 }, 0);
			auto g3 = p->add_cbutton((char*)u8"🍑重叠", { 380,130 }, 3);
			g3->_absolute = true;
			g3->pos = { 30,120 };
			g3->font_size = 30;
			gb2->font_size = 28;
			g3->text_align = { 0,0.5 };
			gb2->effect = uTheme::light;
			gb2->hscroll = {};
			gb2->rounding = 14;
			glm::vec2 text_aligns[7] = { {0,0},{0.5,0},{0.0,0.5},{0.5,0.5},{1,0},{0.0,1},{1,1} };
			gb2->click_cb = [=](void* ptr, int clicks)
				{
					//form1->bind(listp);	// 绑定到新窗口	
					listp->draggable = true;
					listp->set_pos({});
					//form1->raise();
					auto btn = (color_btn*)ptr;
					auto pos = (glm::ivec2)btn->pos + btn->parent->get_pos();
					pos.y += btn->size.y;
					static int xt = 0;
					static int xk = 0;
					//form1->hide();
					//div->add_child(0, { 60,60 });
					div->layout();
					auto cbt = p->add_cbutton((char*)u8"🍑new", { 80,30 }, xt++);
					if (xt > 4)xt = 0;
					cbt->font_size = 16;
					cbt->effect = uTheme::light;
					cbt->pdc;
					cbt->hscroll = { get_rand(0,1),get_rand(0,1) };
					cbt->light = 0.36;
					cbt->rounding = 4;
					cbt->text_align = text_aligns[xk]; xk++;
					if (xk > 6)xk = 0;
					cbt->mevent_cb = [=](void* pt, int type, const glm::vec2& mps)
						{
							auto cp = (color_btn*)pt;
							auto t = (event_type2)type;
							switch (t)
							{
							case event_type2::on_click:
								break;
							case event_type2::on_dblclick:
								break;
							case event_type2::on_tripleclick:
								break;
							case event_type2::on_move:
								break;
							case event_type2::on_down:
							{
								auto cps = cp->get_pos();
								cps.y += cp->size.y + cp->thickness;
								pm3->show(cps);
							}
							break;
							case event_type2::on_up:
								break;
							case event_type2::on_drag:
							{
								p->move2end(cp);
								cp->pos = mps;
							}
							break;
							default:
								break;
							}
						};
					cbt->click_cb = [=](void* ptr, int clicks)
						{
							//form0->bind(listp);	// 绑定到新窗口	
							listp->draggable = true;
							static int kc = 0;
							if (kc != 0)return;
							kc++;
							//form1->show();
							//form1->close();
						};
				};
			g3->mevent_cb = [=](void* p, int type, const glm::vec2& mps)
				{
					static int enterst = 0;
					auto pc = (color_btn*)p;
					auto t = (event_type2)type;
					switch (t)
					{
					case event_type2::on_click:
						break;
					case event_type2::on_dblclick:
						break;
					case event_type2::on_tripleclick:
						break;
					case event_type2::on_move:
						break;
					case event_type2::on_enter:
						enterst++;
						break;
					case event_type2::on_hover:
					{
						// 0.5秒触发悬停事件
						style_tooltip stp = {};
						stp.family = fontn;
						stp.fonst_size = 14;
						glm::vec2 cps = mps;
						cps.y += 20;
						if (enterst == 1) {
							show_tooltip(form0, (char*)u8"提示信息！", cps, &stp);
						}
						enterst++;
					}
					break;
					case event_type2::on_leave:
					{
						enterst = 0;
						hide_tooltip(form0);
					}
					break;
					case event_type2::on_down:
						hide_tooltip(form0);
						break;
					case event_type2::on_up:
						hide_tooltip(form0);
						break;
					case event_type2::on_scroll:
						break;
					case event_type2::on_drag:
					{
						hide_tooltip(form0);
						pc->pos = mps;
					}
					break;
					default:
						break;
					}
				};

			gb2->mevent_cb = [=](void* p, int type, const glm::vec2& mps)
				{
					auto cp = (color_btn*)p;
					if ((int)event_type2::on_down == type)
					{
						auto cps = cp->get_pos();
						cps.y += cp->size.y + cp->thickness;
						cps.y *= -1;
						pm3->show(cps);
					}
				};
			p->draw_back_cb = [=](cairo_t* cr, const glm::vec2& scroll)
				{
					auto v3 = vkd ? vkd->get_value(0) : glm::vec3();
					g3->str = (char*)u8"한ABCabc x:" + pg::to_string(v3.x, "%.3f") + " y:" + pg::to_string(v3.y, "%.3f") + "	z:" + pg::to_string(v3.z, "%.3f");
					//cairo_as _cas(cr);
					cairo_translate(cr, 6, 50);

					//div->draw(cr);
					//draw_image(cr, imgsur, { 10,10 }, { 0,0,-1,-1 }, -1, ds);// { 500, 500 }, { 100,100,100,100 });
					return;
				};
			p->draw_front_cb = [=](cairo_t* cr, const glm::vec2& scroll)
				{
					//cairo_as _cas(cr);
					cairo_translate(cr, 6, 50);

					return;
				};
		}
	}
	// 创建列表视图
	listp->set_border({ 0x80ff802C,1,5,0xff333333 });
	pw->bind(listp);	// 绑定到窗口	
	listp->add_familys(fontn, 0);
	listp->add_familys(fontn2, 0);
	{
		listp->draggable = true; //可拖动
		listp->set_size({ 1600,800 });
		listp->set_pos({ 10,10 });
		auto pss = listp->get_size();
		int width = 10;
		int rcw = 8;
		{
			// 设置带滚动条
			listp->set_scroll(width, rcw, { 0,0 });
			listp->set_scroll_hide(1);
		}
		column_lv c = {};
		c.width = 100;
		c.title = (char*)u8"名称";
		listp->add_title(c);
		c.title = (char*)u8"状态";
		listp->add_title(c);
		c.title = (char*)u8"描述";
		listp->add_title(c);

		plane_cx* p = listp;
		p->custom_layout = true;
		p->fontsize = 16;

		// 进度条
		auto pro0 = p->add_progress("%", { 100,30 }, 0.06);
		pro0->rounding = 10;
		pro0->pos = { 100,100 };
		pro0->hscroll = {};
		std::vector<std::string> cstr = { (char*)u8"名称" ,(char*)u8"状\t态",(char*)u8"描述" };
		std::vector<std::string> cstr1 = { (char*)u8"checkbox 🍇测试1" ,(char*)u8"checkbox ✅测试2",(char*)u8"" };
		std::vector<std::string> cstr2 = { (char*)u8"radio 🍍测试1" ,(char*)u8"radio 测试2",(char*)u8"radio 测试3" };
		width = 150;
		std::vector<color_btn*> cbv = new_label(p, cstr, width, [](void* ptr, int clicks)
			{
				auto pr = (color_btn*)ptr;

			});
		std::vector<checkbox_com> ckv = new_checkbox(p, cstr1, width, [=](void* ptr, bool v)
			{
				auto pr = (checkbox_tl*)ptr;
				//form0->enable_window(1);
			});
		std::vector<radio_com> rcv = new_radio(p, cstr2, width, [=](void* ptr, bool v)
			{
				auto pr = (radio_tl*)ptr;
			});
		auto gv = new grid_view();
		gv->set_size(3, 10);
		gv->_pos = { 6,6 };
		for (size_t i = 0; i < 3; i++)
		{
			gv->set_width(i, width + 30);
		}
		for (size_t i = 0; i < 10; i++)
		{
			gv->set_height(i, 30);
		}
		auto cs = gv->get_size();
		auto vs = p->get_size();
		vs -= 22;
		p->set_view(vs, { 1500,1620 });
		for (size_t i = 0; i < cbv.size(); i++)
		{
			auto rc = gv->get({ i,0 });
			auto it = cbv[i];
			it->pos = rc;
			it->pos += 4;
		}
		for (size_t i = 0; i < ckv.size(); i++)
		{
			auto rc = gv->get({ i,1 });
			auto& it = ckv[i];
			it.c->pos = rc;
			it.b->pos = rc;
			it.b->pos.x += it.c->size.x;
			it.c->pos += 4;
			it.b->pos += 4;
		}
		for (size_t i = 0; i < rcv.size(); i++)
		{
			auto rc = gv->get({ i,2 });
			auto& it = rcv[i];
			it.c->pos = rc;
			it.b->pos = rc;
			it.b->pos.x += it.c->size.x;
			it.c->pos += 4;
			it.b->pos += 4;
		}
		//svg_cx* bl = new_svg_file("blender_icons.svg", 0, 96);
		svg_cx* bl = new_svg_file("Ghostscript_Tiger.svg", 0, 96);
		svg_cx* bl1 = new_svg_file("button20.svg", 0, 96);
		svg_cx* bl2 = new_svg_file("button21.svg", 0, 96);
		int xn = bl->width * 2 * bl->height * 2;
		auto blsur = new_image_cr({ bl->width * 2,bl->height * 2 });
		auto pxd = (uint32_t*)cairo_image_surface_get_data(blsur);
		if (pxd)
		{
			auto stride = cairo_image_surface_get_stride(blsur) / 4;
			stride *= bl->height * 2;
			for (size_t i = 0; i < xn; i++)
			{
				pxd[i] = 0;
			}
		}
		static int svginc = 0;
		std::thread th([=]()
			{
				print_time a("load svg");
				cairo_t* cr = cairo_create(blsur);
				render_svg(cr, bl, {}, { 1.0,1.0 }, 0, 0);// "#g14475");
				//render_svg(cr, bl, {}, { 1.0,1.0 }, 0, "#g14475");
				render_svg(cr, bl1, { 0,bl->height + 100 }, { 1.0,1.0 }, 0);
				//render_svg(cr, bl2, { 400,bl->height + 100 }, { 1.0,1.0 }, 0);
				svginc = 1;
				cairo_destroy(cr);
				p->set_update();
			});
		th.detach();
		p->draw_back_cb = [=](cairo_t* cr, const glm::vec2& scroll)
			{
				//print_time a("draw svg");
				//cairo_as _cas(cr);
				cairo_translate(cr, 6 + scroll.x, 6 + scroll.y);
				draw_rectangle(cr, { 0,0,cs.x,cs.y }, 4);
				fill_stroke(cr, 0xf05c8042, 0xffff802C, 2, false);
				draw_ellipse(cr, { 200,200 }, { 120,20 });
				fill_stroke(cr, 0xf0805c42, 0xff0080ff, 2, false);
				draw_ellipse(cr, { 400,200 }, { 120,20 });
				fill_stroke(cr, 0x8ffa2000, 0xff4d4dff, 2, false);
				auto ltx = p->ltx;
				if (svginc)
				{
					draw_image(cr, blsur, { 10,320 }, { 0,0,-1,-1 });
				}
				rect_shadow_t rs = {};
				rs.cfrom = { 0,1,0,0.8 }, rs.cto = { 0.0,0.5,0.0,0.5 };
				rs.radius = 8;
				rs.segment = 8;
				// 边框阴影
				//draw_rectangle_gradient(cr, cs.x * 2, cs.y * 2, rs);
				return;
			};
		{
			rect_shadow_t rs = {};
			rs.cfrom = { 0.43,0.4,0.9,1 }, rs.cto = { 0.43,0.4,0.9,1 };
			rs.cfrom = { 0.9,0.4,0.09,1 }, rs.cto = { 0.9,0.4,0.09,1 };
			//rs.cfrom = { 1,0.01,0.09,1 }, rs.cto = { 0,0.01,0.9,1 };
			rs.radius = 10;
			rs.segment = 8;
			rs.cubic = { {0.0,0.96},{0.5,0.39},{0.4,0.1},{1.0,0.01 } };
			p->set_shadow(rs);
		}
	}





	charts_u1* pcu = new charts_u1();
	pcu->set_color({ 0xff000000,0xffff9e40,1,4 });
	pcu->set_rect({ 0,150,800,300 });
	pcu->set_filltype({ 0,1 });
	auto ct = pcu->get_ct();
	int tk = 1;
	ct->tks = 2;
	ct->width = { tk + 4,tk };
	std::string title;
	{
		hz::mfile_t msh;
		auto tp = msh.open_d("sh938.txt", true);// 读取从通达信导出的历史k线数据

		if (tp)
		{
			const char* t = tp;
			int len = msh.size();
			int nc = 0;
			for (;;)
			{
				auto str = get_linestr(&t, len);
				if (str.empty())break;
				if (nc == 0)title = hz::gbk_to_u8(str);
				if (2 > nc++)
				{
					continue;
				}
				pcu->push_line(str.c_str(), str.size());
			}

		}
	}
	pcu->update();
	{
		pl1->draggable = true; //可拖动
		pl1->set_size({ 530,600 });
		pl1->set_pos({ 100,100 });
		//pl1->set_clear_color(pbc);
		pl1->on_click = [](plane_cx* p, int state, int clicks) {};
		pl1->fontsize = 16;
		int fontsize = 26;
		glm::vec2 text_align = { 0.1,0.1 };
		//txt->add_family("Consolas", 0);
		//txt->add_family((char*)u8"XITS Math", 0);
		//auto xps = txt->add_familys((char*)u8"楷体,新宋体", 0);

		//txt->add_text({ 0 + 2,0 + 2,200,90 }, text_align, u8"↣ ↠ ↦ ↤ → ← ↔ ⇒ ⇐ ⇔\n 𝔹 ℂ 𝔽 ℕ ℙ ℚ ℝ 𝕋 ℤ \nα β χ δ Δ γ Γ ϵ ɛ η \nκ λ Λ μ ν ω Ω ϕ φ Φ \nπ Π ψ Ψ ρ σ Σ τ θ ϑ Θ υ \nξ Ξ ζ 𝔸 𝐀 𝔄 𝕬 𝐴 𝑨", -1, 18);
		//txt->clear_family();
		//txt->add_family("Consolas", 0);
		text_align = { 0.0,0.1 };
		auto txt = pl1->ltx;
		glm::vec4 rcc1 = { 0 + 2,0 + 2,260,90 };
		txt->add_text(0, rcc1, { 0,0.5 }, (char*)u8"🍑🍍🌶🍆abcg", -1, 60);
		txt->update_text();
		auto et1 = pl1->add_input("", { 100,22 }, true);
		glm::vec2 bs = { 50,22 };
		et1->set_pos({ 10,10 });


		pl1->add_switch(bs, "", true);
		pl1->add_switch(bs, "", false);
		auto sw1 = (switch_tl*)pl1->add_switch(bs, (char*)u8"开", true);
		auto sw2 = (switch_tl*)pl1->add_switch(bs, "k", false);
		bs.x = 16;
		bs.y = 16;
		{
			auto ck1 = pl1->add_checkbox(bs, "cc", false);
			bs.x = 90;
			bs.y = 30;
			auto kcb = pl1->add_label((char*)u8"🌽玉米", bs, 0);
			kcb->click_cb = [=](void* ptr, int clicks) {
				ck1->set_value();
				};
			ck1->v.on_change_cb = [=](void* p, bool v) {
				//pmodal->visible = v;
				};
		}
		bs.x = 16;
		bs.y = 16;
		{
			auto ck1 = pl1->add_checkbox(bs, "cc1", false);
			bs.x = 90;
			bs.y = 30;
			auto kcb = pl1->add_label((char*)u8"g🍖🌶🌶", bs, 0);
			kcb->click_cb = [=](void* ptr, int clicks) {
				ck1->set_value();
				};
		}
		auto gr = new group_radio_t();
		bs.x = 16;
		bs.y = 16;
		auto r1 = pl1->add_radio(bs, "cc2", true, gr);
		{
			bs.x = 90;
			bs.y = 30;
			auto kcb = pl1->add_label((char*)u8"🍇葡萄", bs, 0);
			kcb->click_cb = [=](void* ptr, int clicks) {
				r1->set_value();
				};

		}
		bs.x = 16;
		bs.y = 16;
		auto r2 = pl1->add_radio(bs, "cc3", true, gr);
		{
			bs.x = 90;
			bs.y = 30;
			auto kcb = pl1->add_label((char*)u8"🥝猕猴桃", bs, 0);
			kcb->click_cb = [=](void* ptr, int clicks) {
				r2->set_value();
				};

		}
		std::vector<progress_tl*> prv;
		{
			auto pro = pl1->add_progress("%", { 100,30 }, 0.06);
			pro->rounding = 10;
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 100,20 }, 0.125);
			pro->rounding = 10;
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 100,20 }, 0.5);
			pro->rounding = 10;
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 100,20 }, 1);
			pro->rounding = 10;
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 160,20 }, 0);
			pro->rounding = 10;
			pro->text_inside = false;
			pro->set_value(0.8);
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 160,20 }, 0);
			pro->rounding = 10;
			pro->text_inside = false;
			pro->set_value(0.98);
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 160,20 }, 0);
			pro->rounding = 10;
			pro->right_inside = true;
			pro->set_value(0.68);
			prv.push_back(pro);
		}
		{
			auto pro = pl1->add_progress("%", { 160,26 }, 0);
			pro->rounding = 12;
			pro->right_inside = true;
			pro->set_value(1);
			prv.push_back(pro);
		}
		{
			auto cp = pl1->add_colorpick(0, 250, 20, true);
			cp->font_size = 16;
			cp->on_change_cb = [=](colorpick_tl* p, uint32_t col)
				{
					for (auto it : prv) {
						it->color.x = col;
					}
				};
			cp->init(0, 250, 20, true);
			cp->set_hsv({ 0.62,1,0.91,0.68 });
		}
		bs = { 200, 12 };
		{
			auto slider = pl1->add_slider(bs, 7, 0.2);
			slider->sl.y = -1;
			slider->thickness = 2;
			slider->rounding = 3;
		}
		{
			bs = { 12, 200 };
			auto slider = pl1->add_slider(bs, 7, 0.2);
			slider->sl.y = 0xff6666ff;
			slider->thickness = 2;
			slider->rounding = 3;
		}
		{
			bs = { 200, 12 };
			auto slider = pl1->add_slider(bs, 7, 0.2);
			slider->sl.y = 0xff6666ff;
			slider->thickness = 2;
			slider->rounding = 3;
			slider->reverse_color = 1;
		}
		{
			bs = { 12, 200 };
			auto slider = pl1->add_slider(bs, 7, 0.2);
			slider->sl.y = 0xff6666ff;
			slider->thickness = 2;
			slider->rounding = 3;
			slider->reverse_color = 1;
		}
		auto pss = pl1->get_size();

		int width = 10;
		int rcw = 8;
		{
			// 设置带滚动条
			pl1->set_scroll(width, rcw, { 0,0 });
			pl1->set_scroll_hide(1);
		}

		sw1->color = { 0xff66ce13, 0xff4949ff ,-1 };
		sw2->color = { 0xff66ce13, 0xff4949ff ,-1 };
		//sw2->text_color = {};
		pl1->_css.align_items = flex_item::flex_align::ALIGN_CENTER;

		pl1->update_cb = [=](float delta)
			{
				return 0;
			};
		pl1->draw_back_cb = [=](cairo_t* cr, const glm::vec2& scroll)
			{
				//cairo_as _cas(cr);
				//cairo_translate(cr, 0, 300);
				//txt->draw_text(cr, 0xff0080ff);
				return;
				if (0) {
					cairo_as _cas(cr);
					cairo_translate(cr, 50.5, 40.5);
					static std::vector<glm::vec2> ptv = {};
					ptv = { {0,0},{0,150},{150,150},{150,0} };
					glm::vec2 sc = { 0.264583319 ,0.264583319 }, bs = { 1.0,1.0 };
					int ddot = 1;
					scale_pts(ptv.data(), ptv.size(), sc, ddot, 0);
					draw_pts(cr, ptv, 0xffff802C);// 渲染路径线

					sc = bs / sc;
					scale_pts(ptv.data(), ptv.size(), sc, ddot, 0);
					draw_pts(cr, ptv, 0xff80ff2C);

					sc = bs / sc;
					scale_pts(ptv.data(), ptv.size(), sc, ddot, 0);
					draw_pts(cr, ptv, 0xff0080ff);
				}

				//return; 
				{
					cairo_as _cas(cr);
					cairo_translate(cr, 10, 50);
					draw_rectangle(cr, { 0.5,0.5,260 + 4,90 + 4 }, 4);
					fill_stroke(cr, 0x80805c42, 0xffff802C, 1, false);
					draw_rectangle(cr, { 330.5,0.5,400 + 4,90 + 4 }, 4);
					fill_stroke(cr, 0xff422e21, 0xffff802C, 1, false);

					draw_rectangle(cr, { 0,0,260 ,90 }, 4);
					draw_rectangle(cr, { 330.5,0.5,400 + 4,90 + 4 }, 4);
					draw_rectangle(cr, { 0,150,800,300 }, 4);
					cairo_clip(cr);
					cairo_new_path(cr);
					txt->draw_text(cr, -1);
					pcu->cidx = std::atoi(et1->_text.c_str());
					pcu->update_draw(cr);
				}
			};
	}
	if (0) {
		pl3->draggable = true; //可拖动
		pl3->set_size({ 1400,600 });
		pl3->set_pos({ 10,10 });
		//pl3->set_clear_color(0xff000000);
		pl3->on_click = [](plane_cx* p, int state, int clicks) {};
		pl3->update_cb = [=](float delta)
			{

				return 0;
			};
		pl3->draw_back_cb = [=](cairo_t* cr, const glm::vec2& scroll)
			{
				return;
				int y1 = 10;
				{
					cairo_as _ss_(cr);

					cairo_set_line_width(cr, 1.0);
					draw_triangle(cr, { 100,100 }, { 8,8 }, { 0,1 });
					fill_stroke(cr, -1, 0);
					draw_triangle(cr, { 100.5,120.5 }, { 4.5,9 }, { 1,0.5 });
					fill_stroke(cr, 0, -1, 1);

					cairo_scale(cr, 5, 5);
					draw_triangle(cr, { 10.5,12.5 }, { 14.5,19 }, { 1,0.5 });
					fill_stroke(cr, 0, -1, 2);
					cairo_set_hairline(cr, 1);// 开启最小宽度线
					draw_triangle(cr, { 15.5,12.5 }, { 14.5,19 }, { 1,0.5 });
					fill_stroke(cr, 0, -1, 2);
				}


				cairo_translate(cr, 200, 200);
				rect_shadow_t rs = {};
				rs.cfrom = { 0,1,0,0.8 }, rs.cto = { 0.0,0.5,0.0,0.5 };
				rs.radius = 20;
				rs.segment = 8;
				//draw_rectangle_gradient(cr, 200, 100, rs);
				auto txt = pl1->ltx;
				//txt->update_text();	
				//cairo_scale(cr, 0.5, 0.5);
				for (auto it : txt->msu)
				{
					auto ss = draw_image(cr, it, { 10, y1 }, { 0,0,1024,512 });
					//y1 += ss.y + 10;
				}

			};
	}
	if (0) {
		pl2->draggable = true; //可拖动*
		pl2->set_size({ 830,600 });
		pl2->set_pos({ 10,10 });
		//pl2->set_clear_color(pbc);
		pl2->on_click = [](plane_cx* p, int state, int clicks) {};
		pl2->draw_back_cb = [=](cairo_t* cr, const glm::vec2& scroll)
			{
			};
		int cc = 1;
		int bc = 0x80ff8222;
		edit_tl* et1, * et2;
		{
			pl2->set_family_size((char*)u8"NSimSun", 16, -1);// 按钮和edit字号标准不同
			auto gb2 = pl2->add_cbutton((char*)u8"🍑图库目录", { 80,30 }, 0);
			gb2->effect = uTheme::light;
			gb2->light = 0.2 * 0;
			gb2->_disabled_events = true;
			gb2->pdc;
			pl2->set_family_size((char*)u8"NSimSun,Segoe UI Emoji", 12, -1);
			et1 = pl2->add_input("", { 400,30 }, true);
			et1->set_pwd('*');
			et2 = pl2->add_input("", { 620,300 }, false);
			et2->set_autobr(true);
		}
		pl2->set_family_size((char*)u8"NSimSun", 16, -1);// 按钮和edit字号标准不同
		{
			{
				njson bf = hz::read_json("temp/bfinfo.json");
				std::string ph;
				if (bf.is_object() && bf.find("folder") != bf.end())
				{
					ph = (bf["folder"]);
					et1->set_text(ph.c_str(), ph.size());
				}
			}
			auto gb2 = pl2->add_gbutton((char*)u8"生成索引", { 100,30 }, 0);

			gb2->click_cb = [=](void* ptr, int clicks)
				{
					njson bf = hz::read_json("temp/bfinfo.json");
					std::string ph;
					if (bf.is_object() && bf.find("folder") != bf.end())
					{
						ph = hz::u8_to_gbk(bf["folder"]);
					}

					auto p = (gradient_btn*)ptr;

					auto fpath = et1->_text.size() ? hz::u8_to_gbk(et1->_text) : hz::browse_folder(ph, "选择图片文件夹");
					if (fpath.size())
					{
						double ss = 0.0;
						int cn = 0;
						// todo
						std::string str = (char*)u8"成功添加" + std::to_string(cn) + (char*)u8"张图片，耗时(秒):" + pg::to_string(ss) + "\n";
						et2->add_text(str.c_str(), str.size());
						fpath += "\n";
						et2->add_text(fpath.c_str(), fpath.size());
					}
					else {
						std::string str = (char*)u8"路径打开失败！请重新输入路径。\n";
						et2->add_text(str.c_str(), str.size());
					}
				};
		}
		{
			auto gb2 = pl2->add_gbutton((char*)u8"清空索引", { 100,30 }, bc);

			gb2->click_cb = [=](void* ptr, int clicks)
				{
					auto p = (gradient_btn*)ptr;
					if (p)
					{

					}
				};
		}
		{
			auto gb2 = pl2->add_gbutton((char*)u8"清空输入框1", { 100,30 }, 0x802282ff);

			gb2->click_cb = [=](void* ptr, int clicks)
				{
					auto p = (gradient_btn*)ptr;
					if (p)
					{
						et1->set_text(0, 0);
						printf((char*)u8"点击数量：%d\n", clicks);
					}
				};
			//	gb2->text_color = 0xff2222ff;
		}
		{
			auto gb2 = pl2->add_gbutton((char*)u8"搜索", { 100,30 }, bc);

			//	gb2->text_color = 0xffff0022;
			gb2->click_cb = [=](void* ptr, int clicks)
				{
					auto p = (gradient_btn*)ptr;
					if (p)
					{
						njson bf = hz::read_json("temp/bfinfo.json");
						std::string ph;
						if (bf.is_object() && bf.find("imagefn") != bf.end())
						{
							ph = hz::u8_to_gbk(bf["imagefn"]);
						}

						std::string filter;
						auto fn = hz::browse_openfile("选择图像文件", "", "所有文件\t*.*\tPNG格式(*.png)\t*.png\tJPEG(*.jpg)\t*.jpg\t", 0, 0);
						if (fn.size()) {
							std::string str;
							for (auto& it : fn)
							{
								str += it + "\n";
							}
							et2->add_text(str.c_str(), str.size());
						}
					}
				};
		}
		{
			auto gb2 = pl2->add_gbutton((char*)u8"清空输入框2", { 100,30 }, 0x802222ff);

			gb2->click_cb = [=](void* ptr, int clicks)
				{
					auto p = (gradient_btn*)ptr;
					if (p)
					{
						et2->set_text(0, 0);
						printf((char*)u8"点击数量：%d\n", clicks);
					}
				};
		}
		pl2->move2end(et2);
		pl2->mk_layout();
	}
#endif
	run_app(app, 0);
	free_app(app);
	return 0;
}
